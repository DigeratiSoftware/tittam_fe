(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,46169,e=>{"use strict";let t=new class{STORAGE_KEY="works";getStoredWorks(){let e=localStorage.getItem(this.STORAGE_KEY);return e?JSON.parse(e):[]}saveWorks(e){localStorage.setItem(this.STORAGE_KEY,JSON.stringify(e))}async createWork(e){await new Promise(e=>setTimeout(e,500));let t={id:Date.now().toString(),status:"pending",...e},s=this.getStoredWorks();return s.push(t),this.saveWorks(s),t}async getWorks(){return await new Promise(e=>setTimeout(e,300)),this.getStoredWorks()}async getWorkById(e){return await new Promise(e=>setTimeout(e,200)),this.getStoredWorks().find(t=>t.id===e)||null}async getWorksByScheme(e){return await new Promise(e=>setTimeout(e,300)),this.getStoredWorks().filter(t=>t.schemeId===e)}async getWorksByComponent(e){return await new Promise(e=>setTimeout(e,300)),this.getStoredWorks().filter(t=>t.componentId===e)}async updateWork(e,t){await new Promise(e=>setTimeout(e,500));let s=this.getStoredWorks(),o=s.findIndex(t=>t.id===e);if(-1===o)throw Error("Work not found");return s[o]={...s[o],...t,updatedAt:new Date().toISOString()},this.saveWorks(s),s[o]}async deleteWork(e){await new Promise(e=>setTimeout(e,300));let t=this.getStoredWorks().filter(t=>t.id!==e);this.saveWorks(t)}async deleteWorksByScheme(e){await new Promise(e=>setTimeout(e,400));let t=this.getStoredWorks().filter(t=>t.schemeId!==e);this.saveWorks(t)}async deleteWorksByComponent(e){await new Promise(e=>setTimeout(e,400));let t=this.getStoredWorks().filter(t=>t.componentId!==e);this.saveWorks(t)}async searchWorks(e){await new Promise(e=>setTimeout(e,300));let t=this.getStoredWorks(),s=e.toLowerCase();return t.filter(e=>e.schemeName.toLowerCase().includes(s)||e.componentName.toLowerCase().includes(s)||e.createdBy.toLowerCase().includes(s)||Object.values(e.fieldData).some(e=>String(e).toLowerCase().includes(s)))}async getWorkStats(){await new Promise(e=>setTimeout(e,200));let e=this.getStoredWorks(),t={total:e.length,pending:0,inProgress:0,completed:0,byScheme:{},byComponent:{},byCreator:{}};return e.forEach(e=>{switch(e.status){case"pending":t.pending++;break;case"in_progress":t.inProgress++;break;case"completed":t.completed++}t.byScheme[e.schemeName]=(t.byScheme[e.schemeName]||0)+1,t.byComponent[e.componentName]=(t.byComponent[e.componentName]||0)+1,t.byCreator[e.createdBy]=(t.byCreator[e.createdBy]||0)+1}),t}async updateWorkStatus(e,t){return this.updateWork(e,{status:t})}};e.s(["workService",0,t])}]);